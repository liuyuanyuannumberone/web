<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

<!--<script>
    // 1.在变量提升阶段：带 var 的只声明不定义， 带function的声明并且定义。
    console.log(a); //undefined
    var a = 1;
    print(); //print
    function print() {
        console.log("print")
    }

    // 2.全局作用域  带不带var的变量会映射到 window 下成为属性
    // var q = p =13 ====> var q=13; p=12;    p不带var
    var m = 13;
    n = 14;
    console.log(window.m, window.n) //13 14
</script>

<script>
    //1.return 一个函数（节流 防抖 柯里化实现）
    var n = 10;
    function fn() {
        var n = 20
        function f() {
            n++;
            console.log(n)
        }
        return f
    }
    var x = fn();
    // x()

    //节流
    function throttle(fn, timeout) {
        let timer = null
        return function (...arg) {
            if(timer) return
            timer = setTimeout(() => {
                fn.apply(this, arg)
                timer = null
            }, timeout)
        }
    }

    //防抖
    function debounce(fn, timeout){
        let timer = null
        return function(...arg){
            clearTimeout(timer)
            timer = setTimeout(() => {
                fn.apply(this, arg)
            }, timeout)
        }
    }

    //柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用
    // 假设我们有一个求长方形面积的函数
    function getArea(width, height) {
        return width * height
    }
    // 如果我们碰到的长方形的宽老是10
    const area1 = getArea(10, 20)
    const area2 = getArea(10, 30)
    const area3 = getArea(10, 40)

    // 我们可以使用闭包柯里化这个计算面积的函数
    function getAreaTest(width) {
        return height => {
            return width * height
        }
    }
    const getTenWidthArea = getAreaTest(10)
    // 之后碰到宽度为10的长方形就可以这样计算面积
    const area = getTenWidthArea(20)



    // 2.函数作为参数
    var m = 1
    function foo() {
        var m = 'foo'
        function fo() {
            console.log(m)
        }
        return fo
    }

    function f(p) {
        var m = 'f'
        p()
    }
    f(foo());


    //3.IIFE（自执行函数）
    var q = 'aaa';
    (function p(){
        console.log(q)
    })()

   //4.循环赋值
    for(var i = 0; i<10; i++){
        (function(m){
            setTimeout(function(){
                console.log(m)
            }, 1000)
        })(i)
    }

    //5.使用回调函数就是在使用闭包
    window.name = '林一一'
    setTimeout(function timeHandler(){
        console.log(window.name);
    }, 100);


</script>-->

<script>
    let arr = [];
    for (var i = 0; i < 10; i++) {
        arr[i] = function () {
            console.log(i)
        }
    }

    for (let j = 0; j < 10; j++) {
        arr[j]()
    }


</script>
</body>
</html>
