一、原型和原型链、继承的区别，应用背景，关系判断  创建对象的过程中发生了什么？
【https://www.php.cn/js-tutorial-417938.html】
原型：
我们创建的每个函数都有一个 prototype 属性，这个属性指向一个对象，也就是原型对象，用途是包含所有实例共享的属性和方法；
         原型对象默认拥有一个constructor 属性，指向它的那个构造函数；
每个对象都拥有一个隐藏的属性 __proto__，指向它的原型对象。



原型链：
js中所有的对象都是由它的原型对象继承而来。
原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是原型链。

instanceof
最常用的确定原型指向关系的关键字，检测的是原型对象,判断两个对象是否属于实例关系  p instanceof Person // true
而不能判断一个对象实例具体属于哪种类型
hasOwnProperty 
可以确定访问的属性是来自于实例本身还是原型对象

原型链的问题
由于原型链的存在，我们可以让很多实例去共享原型上面的方法和属性
引用类型，变量保存的是指针。所以当原型上面的属性是一个引用类型的值时，
我们通过其中某一个实例对原型属性的更改，结果会反映在所有实例上面，这也是原型共享属性造成的最大问题

创建对象的过程：
1. 创建空对象；
2. 设置新对象的__proto__属性指向构造函数的 prototype 对象，设置prototype对象的constructor为构造函数的名称，；
3. 将构造函数的上下文 this 指向新创建的对象，执行构造函数内部的代码（给新对象添加属性）；；
4. 如果构造函数return一个非 null 的对象，那返回的就是这个对象 其他情况一律返回新对象

缺点：每次实例化一个新对象，都会在内部创建一个 sayName 对应的匿名函数，
而这个函数对所有实例来讲是没有必要每次都创建的，他们只需要指向同一个函数即可。

   
二、闭包的原理和使用场景。 https://juejin.cn/post/6937469222251560990
    变量提升：JS代码执行前，浏览器会将带有var, function关键字的变量提前进行声明，这种预先处理的机制
    
    闭包：
        在JS中在函数执行后作用域就会被清理、内存也随之回收，
       但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，
       即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包。
    
       一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，
       即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的
       
     形成闭包的原因：内部的函数存在外部函数的引用就会导致闭包。
                 
     闭包的作用:函数内部的变量保留在内存中，不被销毁,可以读取函数内部的变量 
     
    使用闭包需要注意什么：容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。
                        过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。

 
    闭包的经典使用场景：1.return 回一个函数   2.函数作为参数  3.IIFE（自执行函数）
    
    
JS的异步 （Promise/asyc）



ES6的常用特性（Set、结构赋值、新特性等）
手写深拷贝  
什么是事件冒泡？具体有什么应用？如何阻止事件冒泡？

前端性能优化、内存泄露问题  https://juejin.cn/post/6844904048961781774#comment

1.防抖和节流:
      函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，
      鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，
      会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。
      为了优化体验，需要对这类事件进行调用次数的限制
      
   节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，
   而防抖动只是在最后一次事件后才触发一次函数。
2.   


webpack 
同源策略

     
  存储大小
     cookie 一般大小限制在4kb以内  localStorage/sessionStorage 可以达到5M或更大 
  有效时间   
     localStorage的生命周期是永久，除非用户清除localStorage信息。
     sessionStorage的生命周期为当前窗口或标签页。一旦窗口永久关闭就结束。
  数据与服务器之间的交互方式
              cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端；
              sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
      
    
箭头函数
  箭头函数的写法  
     1.如果只有一条语句，可以将{}和return省略掉 v=>v+v;    如果语句为多条，则不可以省略{}和return
     2.当没有参数或有多个参数时，需要用括号（）括起来: （num1,num2)=>num1+num2;
  箭头函数不能用作构造函数
  箭头函数不绑定this  箭头函数没有自己的this，其内部的this绑定到它的外围作用域
  箭头函数无法使用 call或 apply来改变其运行的作用域。
 

项目越做越大，依赖包越来越多，打包文件太大
单页面应用首页白屏时间长，用户体验差


首页按需引入文件 

  路由组件按需加载    component: resolve => require.ensure([], () => resolve(require('@/components/index')))
  第三方组件和插件    import { Button } from 'element-ui'

减小打包后的文件大小   

  生产环境关闭 sourceMap
  代码压缩  ParallelUglifyPlugin   对图片进行压缩 image-webpack-loader
  提取公共代码  CommonsChunkPlugin  
  减少 ES6 转为 ES5 的冗余代码    babel-plugin-transform-runtime 
  CDN 优化 
     vue、vue-router、vuex、element-ui 和 axios 这五个库，全部改为通过 CDN 链接获取，在 index.html 里插入 相应链接。




