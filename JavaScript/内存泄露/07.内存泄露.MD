# 内存泄露：
  ## 原因：当不同生命周期的两个东西相互通信时，一方生命到期该回收了，却被另一方还持有时，也就发生内存泄漏了
  ## 哪些情况会引起内存泄漏？
    1.全局变量
     全局变量的生命周期最长，直到页面关闭前，它都存活着，所以全局变量上的内存一直都不会被回收；
    2.定时器
      setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，并不挂靠在页面上。
       当在某个页面使用了定时器，当该页面销毁时，如果没有手动去释放这些定时器的话，那么定时器还是存活着
        当前页面通过定时器注册了某个回调函数，回调函数内又有当前页面某个变量，就会导致即使页面销毁了，
        定时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏，如果此时再次打开同个页面，
        内存中其实是有双份页面数据的，如果多次关闭、打开，那么内存泄漏会越来越严重
    3.闭包
      函数本身会持有它定义时所在的词法环境的引用，但通常情况下，使用完函数后，该函数所申请的内存都会被回收了        
      但当函数内再返回一个函数时，由于返回的函数持有外部函数的词法环境，而返回的函数又被其他生命周期东西所持有，
      导致外部函数虽然执行完了，但内存却无法被回收
    4.DOM 元素
      DOM元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了;
      但如果某个 DOM 元素，在js中也持有它的引用时，那么它的生命周期就由js和是否在DOM 树上两者决定了，
      记得移除时，两个地方都需要去清理才能正常回收它
    5. 网络回调
      在某个页面发起网络请求，并注册一个回调，且回调函数内持有该页面某些内容，
      那么当该页面销毁时，应该注销网络的回调,否则因为网络持有页面部分内容，也会导致页面部分内容无法被回 
  ## 内存泄漏分类:
       1.比较严重的，泄漏的就一直回收不回来了
       2.就是没有及时清理导致的内存泄漏
  ## 如何监控内存泄漏?
   
