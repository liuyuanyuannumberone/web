# 内存分配与浏览器垃圾回收机制
  ## 内存分配
  当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存
  当系统发现这些变量不再被使用的时候，会自动释放（垃圾回收）这些变量的内存，开发者不用过多的关心内存问题。
 
  ## 数据类型:简单类型和引用类型
   对于简单类型，内存是保存在栈（stack）空间中;复杂数据类型，内存是保存在堆（heap）空间中
   基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间。我们通过按值来访问的
   引用类型：值大小不固定，栈内存中存放地址，指向堆内存中的对象。是按引用访问的
 

## 浏览器垃圾回收机制
   栈的内存空间，只保存简单数据类型的内存，由 `操作系统` 自动分配和自动释放。
   堆空间中的内存，由于大小不固定，系统无法进行自动释放，这个时候就需要 `JS引擎` 来手动的释放这些内存
  ### 垃圾回收的限制？
    在Chrome中,v8被限制了内存的使用(64位约1.4G/1464MB,32位约0.7G/732MB)
   如果清理大量的内存垃圾是很耗时间，这样会引起JavaScript线程暂停执行的时间，那么性能和应用直线下降
 
 ### 垃圾回收的影响？
      浏览器进行垃圾回收的时候，会暂停 JavaScript 脚本，等垃圾回收完毕再继续执行,会阻塞主线程的，
      所以会影响到页面性能，造成卡顿。
 
 ### 垃圾回收器?（只针对对象）
     在JavaScript中，其实绝大多数的对象存活周期都很短，大部分在经过一次的垃圾回收之后，内存就会被释放掉，
     而少部分的对象存活周期将会很长，一直是活跃的对象，不需要被回收。
   #### V8将堆分为新生代和老生代，
       1.新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象；
       2.新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了；
   #### 垃圾回收器
       1.副垃圾回收器（Scavenge）：主要负责新生代的垃圾回收
       2.主垃圾回收器 - Mark-Sweep & Mark-Compact：主要负责老生代的垃圾回收
   #### 垃圾回收算法      
      在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期短，所以需要一个效率非常高的算法。
  ##### 新生代：主要使用Scavenge算法进行垃圾回收，参见Scavenge算法图片
   ###### 如何标记活动对象和非活动对象的？
     有一个概念叫对象的可达性，表示从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。
   ###### 新生代中的对象什么时候变成老生代的对象呢？   
     在新生代中，还进一步进行了细分，分为nursery子代和intermediate子代两个区域，一个对象第一次分配内存时会被分配到新生代中的nursery子代，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 intermediate 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升。       
  ##### 老生代： Mark-Sweep(标记清除) & Mark-Compact(标记整理) 算法
      在老生代空间中的对象都已经至少经历过一次或者多次的回收所以它们的存活概率会更大
      如果这个时候再使用scavenge算法的话，会出现两个问题：
        1.scavenge为复制算法，重复复制活动对象会使得效率低下
        2.scavenge是牺牲空间来换取时间效率的算法，而老生代支持的容量较大，会出现空间资源浪费问题
      `Mark-Sweep`:参见图算法
      `Mark-Compact`:参见图算法

 #### 全停顿 Stop-The-World
      由于垃圾回收是在JS引擎中进行的，而Mark-Compact算法在执行过程中需要移动对象，而当活动对象较多的时候，它的执行速度不可能很快，为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为全停顿（stop-the-world）。

      在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。
      而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿
 ### 优化 Orinoco
      orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它利用了增量标记、懒性清理、并发、并行来降低主线程挂起的时间
      参见图-增量标记和懒性清理，图-并发和并行