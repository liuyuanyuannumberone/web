# 基础部分
 . 匹配一个字符， 除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
                 对于码点大于0xFFFF的Unicode 字符，点字符不能正确匹配
 
 *  {0,} 表示的是前面的表达式出现了0次到多次,和 *一样的
 +  {1,} 表示的是前面的表达式出现了1次到多次,和 +一样的
 ?  {0,1} 表示的是前面的表达式出现了0次到1次,和 ?一样的

惰性匹配:通过在量词后面加个问号就是惰性匹配。在匹配成功的前提下，尽可能少的去匹配
             所有惰性匹配情形如下:{m,n}? ?? +? *?
贪婪匹配：默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。

[^]* 表示匹配一切字符，其中包括换行符
[\S\s]* 指代一切字符
/foo.bar/su 使得.匹配任意字符


{5,10} 表示的是前面的表达式出现了5次到10次
{4} 前面的表达式出现了4次


 ^[0-9] 以数字开头  [a-z]$ 必须以小写字母结束
 cat|dog 或关系  表示的是要么是一个数字,要么是一个小写的字母
## 字符类[]表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内
  ###  脱字符^只有在字符类的第一个位置才有特殊含义，否则就是字面含义
  ###  连字符（-）表示字符的连续范围。当连字号不出现在方括号之中，就不具备简写的作用，只代表字面的含义
       不要过分使用连字符，否则很可能选中意料之外的字符。最典型的例子就是[A-z]，在ASCII编码之中，大写字母与小写字母之间还有其他字符。

   [0-9] 0到9之间的任意的一个数字  [a-z] 所有的小写的字母中的任意的一个
   [0-9a-zA-Z] 所有的数字或者是字母中的一个
   [^xyz]表示除了x、y、z之外任意一个都可以匹配 

  如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符
     var s = 'Please yes\nmake my day!';
     s.match(/yes.*day/) // null
     s.match(/yes[^]*day/) // [ 'yes\nmake my day']

 
        
\d 匹配0-9之间的任一数字，相当于[0-9]。
\D 匹配所有0-9以外的字符，相当于[^0-9]。
\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。
\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。  
\b 匹配词的边界。
\B 匹配非词边界，即在词的内部。


# 正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠  \
  ^ . [ $ ( ) | *  +  ?  {  /


## 字符串的实例方法之中，有4种与正则表达式有关。
   String.prototype.match()
   String.prototype.search()
   String.prototype.replace()
   String.prototype.split()